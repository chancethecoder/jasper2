---
layout: post
current: post
cover: False
navigation: True
title: Hoisting
date: 2017-12-25 11:00:00
tags: [til, javascript]
class: post-template
subclass: 'post tag-til tag-javascript'
author: chancethecoder
---

<h2>Example</h2>
<p>JS를 하다보면 hoisting이라는 단어를 볼 때가 있다. hoisting은 과연 무엇일까?</p>
<p>YDKJS의 예제를 살펴보자.</p>

<pre><code class="nohighlight">a = 2;
var a;
console.log(a); // 2
</code></pre>

<p>두 번째 줄에서 a가 다시 선언됐기 때문에 <code>undefined</code>가 출력될 것 같지만, 2가 출력된다. 그렇다면 a가 위로 올라가는 걸까?</p>
<p>다음을 보자</p>

<pre><code class="nohighlight">console.log(a); // undefined
var a = 2;
</code></pre>

<p>???</p>

<h2>Compiling</h2>
<p>JS 엔진은 코드를 인터프리팅하기 전에 컴파일 과정을 거친다.</p>
<p>예를 들어, <code>var a = 2;</code>라는 코드가 있으면</p>
<ol>
    <li>
        <code>var a</code>와 <code>a = 2</code>로 쪼갠다
        <ul>
            <li>선언부: <code>var a</code></li>
            <li>실행부: <code>a = 2</code></li>
        </ul>
    </li>
    <li>
        실행부는 제자리에, 선언부는 코드 블럭의 맨 위로 끌어올린다 (실제로는 참조 가능하도록 만드는 것 뿐이다)
    </li>
</ol>
<p>이러한 동작을 <strong>Hoisting</strong>이라고 한다.</p>
<p>예제를 다시 보자.</p>

<pre><code class="nohighlight">// compilation phase
var a;

// execution phase
a = 2;
console.log(a);
</code></pre>

<p>첫 번째를 이렇게 놓고 보면 말이 되는 것 같다.</p>
<p>이번엔 두 번째를 보자.</p>

<pre><code class="nohighlight">// compilation phase
var a;

// execution phase
console.log(a);
a = 2;
</code></pre>

<p>보이는 것처럼, 당연히 <code>undefined</code>가 나오는 코드다.</p>

<h2>Per Scope</h2>
<p>hoisting은 현재 scope의 맨 위로 끌어올려질 뿐이지, 프로그램의 첫 줄로 오는게 아니다.</p>

<pre><code class="nohighlight">foo();

function foo() {
    console.log( a ); // undefined
    var a = 2;
}
</code></pre>

<p>이 코드를 엔진에서는 아래와 같이 해석한다.</p>

<pre><code class="nohighlight">function foo() {
    var a;
    console.log( a ); // undefined
    a = 2;
}

foo();
</code></pre>

<p>바깥 scope에서 <code>function foo(){...}</code>에 hoisting이 일어나고, 함수 내 scope에서 <code>var a</code>에 hoisting이 일어난다.</p>

<h2>Function Expression</h2>
<p>함수 표현식 or 화살표 함수 문법으로 변수에 함수를 할당할 수도 있다.  </p>

<pre><code class="nohighlight">foo(); // TypeError

var foo = function bar() {
    // ...
};
</code></pre>

<p>위 코드에서 무슨 일이 벌어졌는지 알아보자.</p>
<p>먼저 <code>foo</code> 변수에 <code>bar()</code> 함수를 할당했다.</p>
<p>이게 컴파일 되면 함수 표현식을 선언부, 실행부로 쪼개어 <code>foo</code>가 hoisting될 것이다.</p>
<p>최종 형태는 다음과 같다.</p>

<pre><code class="nohighlight">var foo;
foo(); // TypeError

foo = function bar() {
    // ...
};
</code></pre>

<p>이제 line by line으로 읽어보면,</p>
<p><code>foo</code>가 선언은 됐지만 <code>undefined</code> 상태인데 함수 호출을 시도하는 코드가 돼버렸다.</p>
<p>그리고 <code>ReferenceError</code>가 아니라 <code>TypeError</code>가 발생한다. (변수 참조는 가능하기 때문에)</p>
<p>위 예제를 좀 더 디테일하게 파고들어보자.</p>

<pre><code class="nohighlight">foo(); // TypeError
bar(); // ReferenceError

var foo = function bar() {
    // ...
};
</code></pre>

<p>이 코드는 다음과 같이 해석된다.</p>

<pre><code class="nohighlight">var foo;
foo(); // TypeError
bar(); // ReferenceError

foo = function() {
    var bar = ...self...
    // ...
}
</code></pre>

<p>유명 함수 표현식이 자기 자신을 외부 scope에서 호출한 경우다.</p>
<p><code>bar</code>가 블럭 scope에 있기 때문에 global scope에선 <code>ReferenceError</code>가 발생한다.</p>
